  The DigitalFilter object is a subclass of the AnalogFilter object.  The reason for structuring the hierarchy this way is to enable the DigitalFilter object to inherit some of the methods in AnalogFilter for creating analog prototype filters.
  In order to find a particular type of digital filter, one must first call the method, findPolesZeros, which in turn calls the super class's method, findAnalogPolesZerosFor:omega0:bandwidth:.  In calling findPolesZeros, the filterType must be specified to be digital, the filterPassType(defined in AnalogFilter.h) must be specified to be LOW_PASS, HIGH_PASS, etc., the analogType(defined in AnalogFilter.h) must be specified to be BUTTERWORTH, CHEBYSHEV, etc., and the filterOrder must be specified.  All of these initializations are normally performed in initWithPassType:fo:fc:fs:order:.  The digital poles and zeros are then stored in the instance variables digitalPoles and digitalZeros.
  If the transfer function is desired, then call findTransferFunction.  The transfer function coefficients are stored in the polynomial objects, aPolyObject, and bPolyObject.  I believe the C routine, poly_roots.c is only needed for finding Bessel type of filters.
  Note, the digital filter object also has the capability of finding an FIR filter by windowing the impulse response of an ideal filter with one of several windowing functions.  See the method, transferForFIRWindow, and see the book by Oppenheim and Schafer.

Good luck, frank@dendrite.sps.mot.com